#!/usr/bin/env bash
# vim: et:sw=2:ts=2:ai

# Load environment variables
load_env() {
  # We use "tr" to translate the uppercase "uname" output into lowercase
  UNAME=$(uname -s | tr '[:upper:]' '[:lower:]')
  # Then we map the output to the names used on the Github releases page
  case "$UNAME" in
      linux*)     MACHINE=linux;;
      darwin*)    MACHINE=macos;;
      mingw*)     MACHINE=windows;;
  esac
  export MACHINE

  # OSX requires coreutils
  if [[ "${MACHINE}" == "macos" ]] && ! which gtouch > /dev/null; then
    echo "Required tools are missing, please run: brew install coreutils"
    exit 1
  fi

  if [[ "${MACHINE}" == "macos" ]]; then
    touch() {
      gtouch "$@"
    }
  fi

  # Set the default environment
  export SPECIFIED_ENV=dev

  # Ensure the docker host is accessible
  if [[ "${MACHINE}" == "windows" ]]; then
    HOST_IP=host.docker.internal
  elif [[ "${MACHINE}" == "macos" ]]; then
    HOST_IP=host.docker.internal
  else
    HOST_IP=$(ip -4 addr show docker0 | grep -Po 'inet \K[\d.]+')
  fi
  export HOST_IP

  # Ensure an SSH socket is available
  if [[ "$SSH_AUTH_SOCK" == "" ]]; then
    SSH_AUTH_SOCK="/tmp/.ssh-sock"
    ssh-agent -a "${SSH_AUTH_SOCK}"
  fi
  export SSH_AUTH_SOCK

  source_env "${APP_PROJECT_PATH}"

  PROJECT="${APP_PROJECT}"
  export PROJECT

  CACHE_DIR="${HOME}/.cache/development-manager-docker-compose"
  export CACHE_DIR

  GID=$(id -g)
  export GID
  export UID
  if [[ "${MACHINE}" == "windows" ]]; then
    DC="winpty docker-compose"
    CUID="1000"
    CGID="1000"
    CHOME="/home/app"
  else
    DC="docker-compose"
    CUID="${UID}"
    CGID="${GID}"
    CHOME="${HOME}"
  fi
  export CUID
  export CGID
  export CHOME
}

parse_yaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_\-]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         sub(/-/, "_", vn)
         sub(/-/, "_", $2)
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

source_env() {
  # Configure .env files
  local env="${1}/.env"
  local env_local="${1}/.env.local"

  # Load all variables as if they are exported
  set -a

  # Check and load if environment .env file exists
  # shellcheck source=.env
  if [ -e "$env" ]; then
    source "$env"
  fi

  # Check and load if environment local .env file exists
  # shellcheck source=.env.local
  if [ -e "$env_local" ]; then
    source "$env_local"
  fi

  # Configure .env files for specified SPECIFIED_ENV
  local specified_env="${1}/.env.${SPECIFIED_ENV}"
  local specified_env_local="${1}/.env.${SPECIFIED_ENV}.local"

  # Check and load if environment specific .env file exists
  # shellcheck source=.env.dev
  if [ -e "$specified_env" ]; then
    source "$specified_env"
  fi

  # Check and load if environment specific local .env file exists
  # shellcheck source=.env.dev.local
  if [ -e "$specified_env_local" ]; then
    source "$specified_env_local"
  fi

  # Don't automatically export set variables
  set +a
}

# Container for all supported commands
run() {

  # Initialize primary variables
  APP_SELF_PATH=$(dirname "$(realpath "$0")")
  APP_PROJECT_PATH=$(pwd)
  APP_PROJECT=$(basename "${APP_SELF_PATH}")
  TRAEFIK_LOCATION="$(realpath "$(dirname "$(realpath "$0" )")/traefik")"

  # Turn on and attach to specified container
  attach() {
    $DC up "$1"
    return $?
  }

  # Check system and update if marked old
  autoupdate() {
    local cache_limit
    local cache_project
    local cache_tool

    cache_limit="${CACHE_DIR}/limit"
    cache_project="${CACHE_DIR}/$(pwd | base64)"
    cache_tool="${CACHE_DIR}/dev"

    # Ensure cache directory exists
    test ! -d "${CACHE_DIR}" && mkdir -p "${CACHE_DIR}"

    # Remove old cache files
    find "${CACHE_DIR}" -type f -mtime +1 -delete

    # Set limit of last check
    touch -d '-16 hours' "${cache_limit}"

    # Ensure a last check file exists
    test ! -f "${cache_project}" && touch -d '-17 hours' "${cache_project}"

    # Ensure a last check file exists
    test ! -f "${cache_tool}" && touch -d '-17 hours' "${cache_tool}"

    # Check if the last check exceeds the given limit
    if [ "${cache_limit}" -nt "${cache_project}" ]; then
      touch "${cache_project}"

      echo "Checking if new images are available ..."

      # Run the pull command and download images if available
      pull
    fi

    # Check if the last check exceeds the given limit
    if [ "${cache_limit}" -nt "${cache_tool}" ]; then
      touch "${cache_tool}"

      # Run the self update command
      selfupdate
      check
    fi
  }

  # Open the shell of a container
  console() {
    autoupdate
    restore
    local shell="console"
    [ "$1" != "" ] && shell=$1

    $DC run \
      --rm \
      -u "$(id -u):$(id -g)" \
      --no-deps \
      "$shell"
    return $?
  }

  # Checks whether the current template version of the project is still the latest
  check() {
    if [ -e "docker-compose.yml" ] || [ -e "docker-compose.yaml" ]; then
      if [ -e "docker-compose.yml" ]; then
        eval "$(parse_yaml docker-compose.yml "COMPOSE_VAR_")" &> /dev/null
      elif [ -e "docker-compose.yaml" ]; then
        eval "$(parse_yaml docker-compose.yaml "COMPOSE_VAR_")" &> /dev/null
      fi

      if [ -n "${COMPOSE_VAR_x_custom_type}" ]; then
        local latestFilePath
        latestFilePath="${APP_SELF_PATH}/templates/${COMPOSE_VAR_x_custom_type}/docker-compose.yml"
        eval "$(parse_yaml $latestFilePath "COMPOSE_LATEST_VAR_")" &> /dev/null
        if  [ -n "${COMPOSE_VAR_x_custom_version}" ] || [ -n "${COMPOSE_LATEST_VAR_x_custom_version}" ] && [ "${COMPOSE_LATEST_VAR_x_custom_version}" != "${COMPOSE_VAR_x_custom_version}" ]; then
          echo "The current docker template is outdated, please run \"dev init ${COMPOSE_VAR_x_custom_type} -f\" to update it."
        else
          echo "The current docker template is up-to-date."
        fi
      else
        echo "The current docker template is outdated, please run \"dev init PROJECT_TYPE -f\" to update it."
        echo "Available project types: "
        for type in "${APP_SELF_PATH}"/templates/*; do
          echo "- $(basename "${type}")"
        done
      fi
    fi
  }

  # Run a Docker Compose command
  dc() {
    $DC "$@"
    return $?
  }

  # Turn off all containers or a specific container
  down() {
    # If there is a docker-compose file present in the current directory, use the default.
    if [ -e "docker-compose.yml" ] || [ -e "docker-compose.yaml" ]; then
      $DC down "$@"
      if [ ! -e "${CACHE_DIR}/active_environments" ]; then
          touch "${CACHE_DIR}/active_environments"
      fi
      grep -xFv "$(pwd)" "${CACHE_DIR}/active_environments" > "${CACHE_DIR}/new_active_environments"
      mv "${CACHE_DIR}/new_active_environments" "${CACHE_DIR}/active_environments"

      if [ "$(grep -xFv "${TRAEFIK_LOCATION}" "${CACHE_DIR}/active_environments")" == "" ]; then
        stop_traefik
      fi
    else
      if [ -e "${CACHE_DIR}/known_locations" ]; then
        while read -r location
          do
            if [ -e "${location}/docker-compose.yml" ]; then
              # Change directory so PWD is replaced correctly
              cd "${location}" || exit
              source_env "${location}"
              $DC -f "${location}/docker-compose.yml" down "$@"
              grep -vxF "${location}" "${CACHE_DIR}/active_environments" > "${CACHE_DIR}/new_active_environments"
              mv "${CACHE_DIR}/new_active_environments" "${CACHE_DIR}/active_environments"
            fi
          done < "${CACHE_DIR}/known_locations"
      fi
    fi

    publish_hosts

    return $?
  }

  # Execute a command on a specified container
  exec() {
    restore
    $DC exec "$@"
    return $?
  }

  # Get help for commands
  help() {
    attach() {
      echo "Attach to a container."
      echo "Usage: $0 attach <container-name>"
      return 0
    }

    console() {
      echo "Open up a console on a service."
      echo "Usage: $0 console [service]"
      echo "Options:"
      echo "  service: Defaults to console"
      echo "Available services:"
      load_env
      $DC ps --services | xargs echo " "
      return 0
    }

    check() {
      echo "Check whether the currently used template is up-to-date."
      return 0
    }

    dc() {
      echo "Execute a Docker Compose command directly, using configured .env* files."
      echo "Usage: $0 dc [options...]"
      return 0
    }

    down() {
      echo "Turn off development environment."
      echo "Usage: $0 down [options...]"
      echo "For more info, see: docker-compose help down"
      return 0
    }

    exec() {
      echo "Execute a command on a specified container"
      echo "Usage: $0 exec <container> <command> [options...]"
      echo "Example: $0 exec redis redis-cli flushall"
      echo "For more info, see: docker-compose help exec"
      return 0
    }

    init() {
      echo "Initialize a project type for development."
      echo "Usage: $0 init [-f|--force] <project-type>"
      echo "Available project types: "
      for type in "${APP_SELF_PATH}"/templates/*; do
        echo "- $(basename "${type}")"
      done
      return 0
    }

    logs() {
      echo "Display container output logs."
      echo "Usage: $0 logs [-f] [service]"
      echo "For more info, see: docker-compose help logs"
      return 0
    }

    ps() {
      echo "Display container status for current project"
      echo "Usage: $0 ps"
      echo "For more info, see: docker-compose help ps"
      return 0
    }

    pull() {
      echo "Pull latest development environment images."
      echo "Usage: $0 pull"
      echo "For more info, see: docker-compose help pull"
      return 0
    }

    rediscover() {
      echo "Checks whether cached locations still exist."
      echo "Usage: $0 rediscover"
      return 0
    }

    restore() {
      echo "Restore previous running instances after shutdown."
      echo "Usage: $0 restore"
      return 0
    }

    run() {
      echo "Run a command on the development environment."
      echo "Usage: $0 run <command>"
      echo "For more info, see: docker-compose help run"
      return 0
    }

    selfupdate() {
      echo "Run self update."
      echo "Usage: $0 selfupdate"
      return 0
    }

    up() {
      echo "Turn on development environment."
      echo "Usage: $0 up [options...]"
      echo "For more info, see: docker-compose help up"
      return 0
    }

    # Attempt to run a command or output the help
    if [ "$(type -t "$1")" == "function" ]; then
      "$@"
      return $?
    else
      echo "Usage: $0 <option>"
      echo "The following options are available"
      echo "  attach: Attach to a container"
      echo "  console: Open the console"
      echo "  check: Check if current template is up-to-date"
      echo "  dc: Execute a Docker Compose command"
      echo "  down: Stop the environment"
      echo "  exec: Execute a command on a container"
      echo "  help: display additional information about a command"
      echo "  init: Initialize a project based on a template"
      echo "  logs: Display container output logs"
      echo "  ps: Display container status"
      echo "  pull: Pull latest images"
      echo "  rediscover: Checks cached locations for non-existing environments."
      echo "  restore: Restore last development session"
      echo "  run: Run a command"
      echo "  selfupdate: Run self update"
      echo "  up: Start the environment"
    fi
    return $?
  }

  # Initialize a project type for development
  # shellcheck disable=SC2120
  init() {
    local force=0
    local type=""
    for option in "$@"; do
      case "$option" in
        -f|--force)
          force=1
          ;;
        *)
          if [ "$type" == "" ]; then
            type="$option"
          fi
          ;;
      esac
    done
    if [ "${type}" == "" ]; then
      echo "Error: Type not given"
      help init
      exit 1
    fi
    if [ ! -e "${APP_SELF_PATH}"/templates/"${type}" ]; then
      echo "Error: Type '$type' not found."
      exit 1
    fi
    if [ ! -e "${APP_PROJECT_PATH}/docker-compose.yml" ] && [ ! -e "${APP_PROJECT_PATH}/docker-compose.yaml" ] || [ "$force" == "1" ]; then
      cp -prf "${APP_SELF_PATH}"/templates/"${type}"/* "${APP_PROJECT_PATH}"
      cp -prf "${APP_SELF_PATH}"/templates/"${type}"/.[!.]* "${APP_PROJECT_PATH}"
      echo "Initialized $type project."
      return $?
    elif [ -e "${APP_PROJECT_PATH}/docker-compose.yml" ] || [ -e "${APP_PROJECT_PATH}/docker-compose.yaml" ]; then
      echo "Warning: Project already initialized. Use --force to re-initialize the project"
      exit 1
    fi
    run help init
    exit 1
  }

  # Show container output logs
  logs() {
    $DC logs "$@"
    return $?
  }

  # Show container status
  ps() {
    # If there is a docker-compose file present in the current directory, use the default.
    if [ -e "docker-compose.yml" ] || [ -e "docker-compose.yaml" ]; then
      $DC ps "$@"
    else
      if [ -e "${CACHE_DIR}/known_locations" ]; then
        while read -r location
          do
            if [ -e "${location}/docker-compose.yml" ]; then
              # Change directory so PWD is replaced correctly
              echo "Project located at ${location}:"
              cd "${location}" || exit
              source_env "${location}"
              $DC -f "${location}/docker-compose.yml" ps "$@"
            fi
          done < "${CACHE_DIR}/known_locations"
      fi
    fi

    return $?
  }

  # Publish all hosts with the dev_domain label
  publish_hosts() {
    if [ -e "${CACHE_DIR}/published_hosts" ]; then
      while read -r line;
        do
          kill "$(/bin/ps -ao pid,cmd | grep -Po "[0-9]+ (?=$(echo $line | sed 's/\./\\\./g'))")"
      done < "${CACHE_DIR}/published_hosts"
      rm "${CACHE_DIR}/published_hosts"
    fi

    if [ "$(wc -l < "${CACHE_DIR}/active_environments")" != "0" ]; then
      for line in $(docker inspect -f '{{if .Config.Labels.dev_domain}}{{.Config.Labels.dev_domain}}-{{range .NetworkSettings.Networks}}{{.IPAddress}}:{{end}}{{end}}' $(docker ps -aq)); do
        echo "avahi-publish -a ""$(echo "$line" | cut -f1 -d":" | tr '-' ' ')" >> "${CACHE_DIR}/published_hosts"
      done

      if [ -e "${CACHE_DIR}/published_hosts" ]; then
        while read -r line; do
          $($line > /dev/null 2>&1 &)
        done < "${CACHE_DIR}/published_hosts"
      fi
    fi
  }

  # Pull latest images
  pull() {
    $DC pull "$@"
    return $?
  }

  # Rediscover known locations
  rediscover() {
    if [ ! -e "${CACHE_DIR}/known_locations" ]; then
        touch "${CACHE_DIR}/known_locations"
    fi

    if [ ! -e "${CACHE_DIR}/active_environments" ]; then
        touch "${CACHE_DIR}/active_environments"
    fi

    touch "${CACHE_DIR}/rediscover_known_locations"
    touch "${CACHE_DIR}/rediscover_active_environments"

    echo "Checking known locations"
    while read -r location
      do
        if [ -e "${location}/docker-compose.yml" ]; then
          echo "${location} still exists"
          echo "${location}" >> "${CACHE_DIR}/rediscover_known_locations"
        else
          echo "${location} no longer exists"
        fi
      done < "${CACHE_DIR}/known_locations"

    echo "Updating ${CACHE_DIR}/known_locations"
    mv "${CACHE_DIR}/rediscover_known_locations" "${CACHE_DIR}/known_locations"

    echo "Checking active environments"
    while read -r location
      do
        if [ -e "${location}/docker-compose.yml" ]; then
          echo "${location} still exists"
          echo "${location}" >> "${CACHE_DIR}/rediscover_active_environments"
        else
          echo "${location} no longer exists"
        fi
      done < "${CACHE_DIR}/active_environments"

    echo "Updating ${CACHE_DIR}/active_environments"
    mv "${CACHE_DIR}/rediscover_active_environments" "${CACHE_DIR}/active_environments"
  }

  # Restore previous development session
  restore() {
    rediscover &> /dev/null

    CURRENT_DIRECTORY="$(pwd)"
    while read -r location
      do
        cd "${location}" || exit
        source_env "${location}"
        top_output="$($DC -f "${location}/docker-compose.yml" top)"
        if [[ $top_output == '' ]]; then
          echo "Restoring ${location}"
          $DC -f "${location}/docker-compose.yml" up -d
          if grep -q "dev_domain=" "docker-compose.yml"; then
            publish_hosts
          fi
        fi
      done < "${CACHE_DIR}/active_environments"
      cd "$CURRENT_DIRECTORY" || exit
      return $?
  }

  # Run a command
  run() {
    autoupdate
    restore
    $DC run console "$@"
    return $?
  }

  # Try to self update
  selfupdate() {
    # shellcheck disable=SC2164
    pushd "${APP_SELF_PATH}" > /dev/null
    git pull origin "$(git branch --show-current)"
    chmod +x "$0"
    # shellcheck disable=SC2164
    popd > /dev/null
  }

  # Start the Traefik proxy
  start_traefik() {
    # Create the gateway network if it is not yet running
    if [ "$(docker network list --filter "name=gateway" --format "{{.Name}}")" != "gateway" ]; then
      echo "Setting up gateway network..."
      docker network create \
        --driver=bridge \
        --attachable \
        --internal=false \
        gateway &> /dev/null
    fi

    # Check if Traefik is already active
    if ! grep -qxF "${TRAEFIK_LOCATION}" "${CACHE_DIR}/active_environments" &> /dev/null; then
      $DC -f "${TRAEFIK_LOCATION}/docker-compose.yml" up -d
      echo "${TRAEFIK_LOCATION}" >> "${CACHE_DIR}/active_environments"
    fi
  }

  # Stop the Traefik proxy
  stop_traefik() {
    if grep -qxF "${TRAEFIK_LOCATION}" "${CACHE_DIR}/active_environments" &> /dev/null; then
      $DC -f "${TRAEFIK_LOCATION}/docker-compose.yml" down
      grep -xFv "${TRAEFIK_LOCATION}" "${CACHE_DIR}/active_environments" > "${CACHE_DIR}/new_active_environments"
      mv "${CACHE_DIR}/new_active_environments" "${CACHE_DIR}/active_environments"

      # Remove the gateway network if it is still running
      if [ "$(docker network list --filter "name=gateway" --format "{{.Name}}")" == "gateway" ]; then
        echo "Shutting down gateway network..."
        docker network rm gateway &> /dev/null
      fi
    fi
  }

  # Turn on all containers or a specific container
  up() {
    autoupdate
    restore
    if grep -q "traefik.enable=true" "docker-compose.yml"; then
      start_traefik
    fi

    if ! grep -qxF $(pwd) "${CACHE_DIR}/known_locations" &> /dev/null; then
      pwd >> "${CACHE_DIR}/known_locations"
    fi

    $DC up -d "$@"

    # If the environment is not in the active list, add it
    if ! grep -qxF "$(pwd)" "${CACHE_DIR}/active_environments" &> /dev/null; then
      pwd >> "${CACHE_DIR}/active_environments"
    fi

    if grep -q "dev_domain=" "docker-compose.yml"; then
      publish_hosts
    fi

    return $?
  }

  # Attempt to run a command or output the help
  if [ "$(type -t "$1")" == "function" ]; then
    if [ "$1" == "init" ] || [ "$1" == "help" ] || load_env; then
      "$@"
    fi
    return $?
  else
    help "$@"
    return 1
  fi
}

# Main process execution
main() {
  # Ensure root does not use this
  if [[ "$(id -u)" == "0" ]]; then
    echo "This script should not be run as root."
    exit 1
  fi

  # Ensure this is not executed from a docker container
  if [[ -e /proc/1/cgroup ]] && grep -c docker /proc/1/cgroup > /dev/null; then
    echo "This script should not be run from a docker container."
    exit 1
  fi

  # Run the tool
  run "$@"
  exit $?
}

# Run the manager
main "$@"
